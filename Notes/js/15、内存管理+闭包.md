# 十五、JavaScript内存管理和闭包

## 1. 认识内存管理

- 不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的，不同的是**某些编程语言**需要我们**自己手动的管理内存**，
  **某些编程语言**会可以**自动帮助我们管理内存**：
- 不管以什么样的方式来管理内存，**内存的管理都会有如下的生命周期**：
  - 第一步：**分配申请你需要的内存**（申请）；
  - 第二步：**使用分配的内存**（存放一些东西，比如对象等）；
  - 第三步：**不需要使用时，对其进行释放**；
- **不同的编程语言对于第一步和第三步会有不同的实现：**
  - **手动管理内存**：比如C、C++，包括早期的OC，都是需要手动来管理内存的申请和释放的（malloc和free函数）；
  - **自动管理内存**：比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存；
- **对于开发者来说，JavaScript 的内存管理是自动的、无形的。**
  - 我们创建的 **原始值、对象、函数……这一切都会占用内存**；
  - 但是我们 **并不需要手动来对它们进行管理，JavaScript引擎** 会帮助我们处理好它；



## 2. JavaScript的内存管理

- JavaScript会在**定义数据时**为我们分配内存。

- **但是内存分配方式是一样的吗？**

  - JS对于 **原始数据类型内存的分配** 会在执行时，直接在栈空间进行分配；

  - JS对于 **复杂数据类型内存的分配** 会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用；

    ![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCZ5uD.png)



## 3. JavaScript的垃圾回收

- 因为**内存的大小是有限**的，所以当**内存不再需要的时候**，我们需要**对其进行释放**，以便腾出**更多的内存空间**。
- 在**手动管理内存的语言**中，我们需要通过**一些方式自己来释放不再需要的内存，比如free函数**：
  - 但是这种管理的方式其实 **非常的低效**，影响我们 **编写逻辑的代码的效率**；
  - 并且这种方式对 **开发者的要求也很高**，并且 **一不小心就会产生内存泄露**；
- 所以大部分**现代的编程语言都是有自己的垃圾回收机制**：
  - 垃圾回收的英文是 **Garbage Collection**，简称 **GC**；
  - 对于 **那些不再使用的对象**，我们都称之为是 **垃圾**，它需要被 **回收**，以释放更多的内存空间；
  - 而我们的语言运行环境，比如Java的运行环境JVM，JavaScript的运行环境js引擎都会内存 **垃圾回收器**；
  - **垃圾回收器** 我们也会简称为 **GC**，所以在很多地方你看到GC其实指的是垃圾回收器；



## 4. 常见的GC算法

### 4.1 引用计数

- 当 **一个对象有一个引用指向它** 时，那么这个 **对象的引用就+1**；

- 当一个 **对象的引用为0** 时，这个对象就 **可以被销毁掉**；

- **这个算法有一个很大的弊端就是会产生循环引用；**

  ![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCZHUA.png)

### 4.2 标记清除

- 标记清除的核心思路是 **可达性（Reachability）**

- 这个算法是设置一个 **根对象（root object），垃圾回收器** 会定期 **从这个根** 开始，找所有从根开始 **有引用到的对象**，对于那些 **没有引用到的对象，就认为是不可用的对象**；

- 这个算法 **可以很好的解决循环引用** 的问题；

  ![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCZjv8.png)

### 4.3 其他算法优化补充

- **标记整理（Mark-Compact）** 和“标记－清除”相似；
  - 不同的是，回收期间同时会将保留的存储对象 **搬运汇集到连续的内存空间**，从而 **整合空闲空间，避免内存碎片化**；
- **分代收集（Generational collection）**—— 对象被分成两组：**“新的”和“旧的”**。
  - 许多对象出现，完成它们的工作并很快死去，它们可以 **很快被清理**；
  - 那些长期存活的对象会变得 **“老旧”**，而且 **被检查的频次也会减少**；
- **增量收集（Incremental collection）**
  - 如果有许多对象，并且我们 **试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟**。
  - 所以引擎试图 **将垃圾收集工作分成几部分来做**，然后 **将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟**；
- **闲时收集（Idle-time collection）**
  - 垃圾收集器 **只会在 CPU 空闲时尝试运行，以减少可能对代码执行** 的影响。



## 5. 闭包

### 5.1 闭包的定义

- **MDN对JavaScript闭包的解释**
  - 一个函数和对其周围状态**（lexical environment，词法环境）**的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包（closure）**；
  - 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
  - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；
- **个人理解和总结**
  - 一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包；
  - **从广义的角度来说**：JavaScript中的函数都是闭包；

### 5.2 闭包的内存泄漏

- **为什么经常会说闭包是有内存泄露的呢？**

  - 在下面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父作用域AO也应该被销毁掉；
  - 但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引用，所以最终会造成这些内存都是无法被释放的；
  - 所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的；

- **那么，怎么解决这个问题呢？**

  - 因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了；
  - 在GC的下一次检测中，它们就会被销毁掉；

  ```JavaScript
  function makeAdder(count) {
    return function (num) {
      return count + num
    }
  }
  
  var add10 = makeAdder(10)
  console.log(add10(5))
  
  add10 = null
  ```

### 5.3 闭包的内存泄漏测试

![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCeEvT.png)



## 6. AO不使用的属性优化

- **我们来研究一个问题：AO对象不会被销毁时，是否里面的所有属性都不会被释放？**

  - 下面这段代码中name属于闭包的父作用域里面的变量；

  - 我们知道形成闭包之后count一定不会被销毁掉，那么name是否会被销毁掉呢？

  - 这里我打上了断点，我们可以在浏览器上看看结果；`name is not defined`

    ![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCe8xK.png)


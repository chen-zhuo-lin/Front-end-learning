# 十六、JavaScript ES5中实现继承

## 1. 认识对象的原型

- **JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。**
- **那么这个对象有什么用呢？**
  - 当我们通过引用对象的 **属性key来获取一个value** 时，它会 **触发 [[Get]]** 的操作；
  - 这个操作会 **首先检查该对象是否有对应的属性**，如果有的话就使用它；
  - **如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性**；
- 那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？
  - 答案是有的，只要是对象都会有这样的一个内置属性；
- **获取的方式有两种：**
  - 方式一：通过对象的 __proto__ 属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）；
- 方式二：通过` Object.getPrototypeOf `方法可以获取到；



## 2. 函数的原型 prototype

- **新的概念：所有的函数都有一个prototype的属性（注意：不是__proto__）**

  ```javascript
  function foo(){}
  
  // 所有的函数都有一个属性，叫prototype
  console.log(foo.prototype)
  ```

- 是不是因为函数是一个对象，所以它有prototype的属性呢？

  - 不是的，因为它是一个函数，才有了这个特殊的属性；
  - 而不是它是一个对象，所以有这个特殊的属性；

  ```javascript
  var obj = {}
  
  obj.prototype // obj就没有这个属性
  ```



## 3. 创建对象的内存表现

![](https://raw.githubusercontent.com/chen-zhuo-lin/pictures/main/2022-11/20221112130526.png)



## 4. prototype添加属性

![](C:\Users\czl20\AppData\Roaming\Typora\typora-user-images\1668229599079.png)



## 5. constructor属性

- 事实上原型对象上面是有一个属性的：**constructor**

  - 默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象；

  ```JavaScript
  function Person() {
    
  }
  
  Person.prototype.constructor // [Function: Person]
  p1.__proto__.constructor // [Function: Person]
  p1.__proto__.constructor.name // Person
  ```



## 6. 重写原型对象

- 如果我们需要在原型上添加过多的属性，通常我们会重写整个原型对象：

  ```javascript
  function Person() {
    
  }
  
  Person.prototype = {
    name: 'why',
    age: 18
  }
  ```

- 前面我们说过, 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性；

  - 而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是
    Person构造函数了

### 6.1 原型对象的constructor

- 如果希望constructor指向Person，那么可以手动添加：

- 上面的方式虽然可以, 但是也会造成constructor的[[Enumerable]]特性被设置了true.

  - 默认情况下, 原生的constructor属性是不可枚举的.
  - 如果希望解决这个问题, 就可以使用我们前面介绍的Object.defineProperty()函数了.

  ```javascript
  Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person
  })
  ```



## 7. 创建对象 – 构造函数和原型组合

- 让所有的对象去共享这些函数

  ```javascript
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  
  Person.prototype.eating = function() {
    console.log(this.name,'在吃东西')
  }
  
  var p1 = new Person('czl', 20)
  p1.eating()
  ```



## 8. 面向对象的特性 – 继承

- 面向对象有三大特性：封装、继承、多态
  - 封装：我们前面将属性和方法封装到一个类中，可以称之为封装的过程；
  - 继承：继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提（纯面向对象中）；
  - 多态：不同的对象在执行时表现出不同的形态；
- **那么继承是做什么呢？**
  - 继承可以帮助我们 **将重复的代码和逻辑抽取到父类** 中，子类只需要直接继承过来使用即可；
  - 在很多编程语言中，**继承也是多态的前提**；



## 9. JavaScript原型链

- **在真正实现继承之前，我们先来理解一个非常重要的概念：原型链。**

  - 我们知道，从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：

  ![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCmQeg.png)

### 9.1 Object的原型

- 那么什么地方是原型链的尽头呢？比如第三个对象是否也是有原型__proto__属性呢？

  ```JavaScript
  obj.__proto__.__proto__.__proto__.__proto__ // [Object: null prototype] {}
  ```

- **我们会发现它打印的是 [Object: null prototype] {}**

  - 事实上这个原型就是我们最顶层的原型了
  - 从Object直接创建出来的对象的原型都是 [Object: null prototype] {}。

- **那么我们可能会问题： [Object: null prototype] {} 原型有什么特殊吗？**

  - 特殊一：**该对象有原型属性**，但是它的原型属性已经指向的是null，也就是已经是顶层原型了；
  - 特殊二：**该对象上有很多默认的属性和方法**；

### 9.2 创建Object对象的内存图

![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCm8Fs.png)

### 9.3 原型链关系的内存图

![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCmGYn.png)

### 9.4 Object是所有类的父类

- **从我们上面的Object原型我们可以得出一个结论：`原型链最顶层的原型对象就是Object的原型对象`**

  ![1667877293238](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCVJW6.png)



## 10. 原型链继承

### 10.1 通过原型链实现继承

- 目前student的原型是p对象，而p对象的原型是Person默认的原型，里面包含running等函数；
- 注意：步骤4和步骤5不可以调整顺序，否则会有问题

```JavaScript
// 1. 定义父类构造函数
function Person(name) {
  this.name =  name
}

// 2. 父类原型上添加内容
Person.prototype.running = function() {
  
}

// 3. 定义子类构造函数
function Student(sno) {
  this.sno = sno
}

// 4. 创建父类对象，并且作为子类的原型对象
var p = new Person()
Student.prototype = p

// 5. 在子类原型上添加内容
Student.prototype.studying = function() {
  
}
```

### 10.2 继承创建对象的内存图

![](https://cdn.jsdelivr.net/gh/chen-zhuo-lin/pictures@main/2022-11/zCmtS0.png)

### 10.3 原型链继承的弊端

- **目前有一个很大的弊端：某些属性其实是保存在p对象上的;**
  - 第一，我们通过 **直接打印对象是看不到这个属性** 的；
  - 第二，这个属性 **会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题**；
  - 第三，**不能给Person传递参数**（让每个stu有自己的属性），因为这个对象是一次性创建的（没办法定制化）；



## 11. 组合继承

### 11.1 借用构造函数继承

- **为了解决原型链继承中存在的问题，开发人员提供了一种新的技术: constructor stealing(有很多名称: 借用构造函数或者称之
  为经典继承或者称之为伪造对象)：**

- **steal是偷窃、剽窃** 的意思，但是这里可以翻译成 **借用**；

- **借用继承的做法非常简单：在子类型构造函数的内部调用父类型构造函数.**

  - 因为函数可以在任意的时刻被调用；

  - 因此通过 **`apply()`和`call()`方法** 也可以在新创建的对象上执行构造函数；

    ```javascript
    function Student(name, friends, sno) {
      Person.call(this, name, friends)
      this.sno = sno
    }
    
    Student.prototype = Person.prototype
    ```

### 11.2 组合借用继承的问题

- 组合继承最大的问题就是无论在什么情况下，都会 **调用两次父类构造函数**。
  - 一次在创建子类原型的时候；
  - 另一次在子类构造函数内部(也就是每次创建子类实例的时候)；
- 所有的子类实例事实上会拥有两份父类的属性:
  - 一份在当前的实例自己里面(也就是person本身的)，另一份在子类对应的原型对象中(也就是person.__proto__里面)；
  - 当然，这两份属性我们无需担心访问出现问题，因为默认一定是访问实例本身这一部分的；



## 12. 寄生组合式继承

### 12.1 原型式继承函数

- **最终的目的：student对象的原型指向了person对象；**

  ```javascript
  function object(obj) {
    function Func() {}
    Func.prototype = obj
    return new Func()
  }
  
  function object(obj) {
    var newObj = {}
    Object.setPrototypeof(newObj, obj)
    return newObj
  }
  
  var student = Object.create(person, {
    address: {
      value: "北京市",
      enumerable: true
    }
  })
  ```

### 12.2 寄生式继承函数

- 寄生式(Parasitic)继承是 **与原型式继承紧密相关的一种思想**, 并且同样 **由道格拉斯·克罗克福德(Douglas Crockford)提出和推广** 的；

- 寄生式继承的思路是 **结合原型类继承和工厂模式** 的一种方式；

- 即 **创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回**；

  ```JavaScript
  function object(obj) {
    function Func() {}
    Func.prototype = obj
    return new Func()
  }
  
  function createStudent(person, name) {
    var newObj = object(person)
    newObj.name = name
    newObj.studying = function() {
      consol.log(this.name,'study')
    }
    return newObj
  }
  ```

### 12.3 寄生组合式继承

- **现在我们来回顾一下之前提出的比较理想的组合继承**

  - 组合继承是比较理想的继承方式, 但是存在两个问题:
  - 问题一: 构造函数会被调用两次: 一次在创建子类型原型对象的时候, 一次在创建子类型实例的时候.
  - 问题二: 父类型中的属性会有两份: 一份在原型对象中, 一份在子类型实例中.

- **事实上, 我们现在可以利用寄生式继承将这两个问题给解决掉.**

  - 你需要先明确一点: 当我们在子类型的构造函数中调用父类型.call(this, 参数)这个函数的时候, 就会将父类型中的属性和方法复
    制一份到了子类型中. 所以父类型本身里面的内容, 我们不再需要.

  - 这个时候, 我们还需要获取到一份父类型的原型对象中的属性和方法.

  - 能不能直接让子类型的原型对象 = 父类型的原型对象呢?

  - 不要这么做, 因为这么做意味着以后修改了子类型原型对象的某个引用类型的时候, 父类型原生对象的引用类型也会被修改.

  - 我们使用前面的寄生式思想就可以了.

    ```javascript
    // 定义object函数
    function object(o) {
      function F(){}
      F.prototype = o
      return new F()
    }
    
    // 定义寄生式核心函数
    function inheritPrototype(Subtype, Supertype) {
      // Subtype.prototype.__proto__ = Supertype.prototype
      // Object.setPrototypeOf(Subtype.prototype, Subtype.prototype)
      Subtype.prototype = createObject(Supertype.prototype)
      Object.defineProperty(Subtype.prototype, "constructor", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: Subtype
      })
      Object.setPrototypeOf(Subtype, Supertype)
      // Subtype.__proto__ = Supertype
    }
    
    inheritPrototype(Student, Person)
    ```



